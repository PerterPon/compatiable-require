# GULU

Gulu是一个基于Koa的上层业务框架。

## 目录
[TOC]

## 一、背景
目前IES的大前端业务以及一些通用平台会采用`NodeJS`作为后端编程语言并使用`Koa`作为基础开发框架。`Koa`是一个很轻量级的框架，具备很强的灵活性，但在业务中直接基于`Koa`开发自由度太大，容易出现各种千奇百怪的目录风格以及代码风格，而且不够高效。因此，我们基于`Koa`编写一套业务框架，一方面是为了统一代码及目录规范，另一方面是为了提升开发及协作效率。

## 二、设计思想
### 2.1 关于Koa
`Koa`的设计非常精巧，内置的概念只有5个，如下：
- `Application`：应用
- `Context`：上下文
- `Request`：请求
- `Response`：响应
- `Middleware`：中间件

基于`Koa`编写应用时，我们基本只会做两类事情：
1. 编写中间件来处理请求
2. 在`Application`实例、`Context`实例、`Request`实例或者`Response`实例上定义一些工具方法或属性，以便在中间件中使用。

所以，编写`Koa`应用其实就是在`Application`、`Context`、`Request`、`Response`、`Middleware`等五个不同的维度去增强`Koa`的能力。

### 2.2 目录规范
在进行框架设计之前，我们确定了目录规范，如下：
```
├── app
│   ├── controller
│   ├── service
│   ├── extension
│   │   ├── app.js
│   │   ├── context.js
│   │   ├── request.js
│   │   └── response.js
│   ├── middleware
│   ├── plugin
│   └── router.js
├── config
└── app.js

```

- `app.js`：应用启动钩子定义文件
- `config`：配置文件目录
- `app/controller`：控制器目录
- `app/service`：业务目录，用于存放可复用的业务逻辑
- `app/extension`：扩展目录，用于扩展`Koa`内置对象的功能
- `app/extension/app.js`：应用扩展定义文件，可在应用实例`app`上定义工具方法或属性
- `app/extension/context.js`：上下文扩展定义文件，可在上下文对象`ctx`上定义工具方法或属性
- `app/extension/request.js`：请求扩展定义文件，可在请求对象`request`上定义工具方法或属性
- `app/extension/response.js`：响应扩展定义文件，可在响应对象`response`上定义工具方法或属性
- `app/middleware`：中间件目录
- `app/plugin`：插件目录
- `app/router.js`：路由定义文件

对于符合目录规范的目录，我们称之为一个目录单元`Unit`。一个目录单元其实就是分别在启动钩子、配置、控制器Controller、业务逻辑Service、扩展、中间件、插件、路由等各个不同的方面定义了应用的能力。我们可以把许多个目录单元都加载到`Koa`中去以增强`Koa`的能力，如下图所示：

![Koa与Unit](http://op1wmr202.bkt.clouddn.com/20180321152160972713258.png)


### 2.3 应用与插件
前面说过，符合目录规范的目录称之为一个目录单元`Unit`。顶层应用目录与插件目录都是符合目录规范的`Unit`。`Unit`之间存在依赖关系，比如应用会依赖插件，插件也可能会依赖其他插件。

对于框架来说，不管是应用目录还是插件目录，它们都是等价的。

框架在加载一个目录单元时，会分析它的依赖关系。一般情况下，我们会从应用目录开始加载，框架会从应用目录开始分析`Unit`之间的依赖，最后得到一棵依赖树，如下图所示：

![Unit依赖树](http://op1wmr202.bkt.clouddn.com/20180321152160976330957.png)

依赖树上的目录单元会被框架以后序遍历的方式依次加载到`Koa`实例上。


## 三、使用指南

### 3.1 安装
```javascript
npm install byted-gulu --registry=http://npm.byted.org/
```

### 3.2 启动
```javascript
// bootstrap.js
const path = require('path');
const Gulu = require('byted-gulu');

// 创建应用
const app = new Gulu({
    root: path.resolve(__dirname),
});

// 加载应用目录并启动
app.load(path.resolve(__dirname)).listen(3000);
```
`Gulu`继承于`Koa`，除了需要在启动前通过`load`方法加载目录单元外，它在使用方式上与`Koa`是一致的。

### 3.3 启动钩子
在某些场景下，我们需要在应用启动前或者启动后去做一些事情，这时可以在`app.js`文件中编写相应的钩子去实现。
```javascript
// app.js
module.exports = {
    async beforeStart(app) {
	    // 应用启动前逻辑
    },
    async afterStart(app) {
        // 应用启动后逻辑
    }
}
```

### 3.4 应用环境
应用环境可以在应用启动时通过`NODE_ENV`环境变量指定，在`Gulu`应用内部可以通过`app.env`访问。

应用环境变量的定义如下：

| 环境 | 变量 |
| --- | --- |
| 开发环境 | dev |
| 生产环境 | prod |
| 测试环境 | test |

### 3.5 配置文件

#### 文件命名
配置文件由默认配置和环境配置组成。默认配置的文件名以`default.js`结尾，环境配置的文件名以`${env}.js`结尾。

`Gulu`支持两种配置方式：聚合性配置和离散型配置。它们的文件命名方式分别如下：
聚合型配置：`config.${env}.js`
离散型配置：`${配置项key}.${env}.js`

聚合型配置会把配置项都收拢到一个文件里面，在项目配置比较简单的时候，可以采用这种方式。离散型配置会以配置项的`key`作为文件名，配置项的`value`作为文件内容，这样可以将配置打散到不同的文件中，在项目配置比较复杂的时候，可以采用这种方式。

聚合型配置
```
├── config
|   ├── config.default.js
|   ├── config.dev.js
|   ├── config.prod.js
└── └── config.test.js
```

离散型配置
```
├── config
|   ├── redis.default.js
|   ├── redis.dev.js
|   ├── redis.prod.js
└── └── redis.test.js
```

#### 配置写法
**方法一：导出配置生成函数，适用于动态配置**
```javascript
module.exports = (app) => {
    return {
        middleware: [
            'koa-body',
        ],
        plugin: [
            'byted-gulu-runtime-ies',
        ],
        koaBody: {
        },
    };
}
```

**方法二：导出配置对象，适用于静态配置**
```javascript
module.exports = {
    middleware: [
        'koa-body',
    ],
    plugin: [
        'byted-gulu-runtime-ies',
    ],
    koaBody: {
    },
};
```

#### 配置优先级
- 环境配置 > 默认配置
- 离散型配置 > 聚合型配置

框架加载目录单元时会按优先级对配置进行深度合并。

应用启动前，框架会按顺序将所有目录单元的配置进行深度合并，然后挂载到`app`实例上。在`Gulu`应用内部，可以通过`app.config`访问配置。


### 3.6 Controller
#### 写法
```javascript
// app/controller/app.js
const { Controller } = require('byted-gulu');

class AppController extends Controller {
    async query(ctx) {        
        const apps = await ctx.service.app.query();
        ctx.body = {
            apps,
        };
    }
}
module.exports = AppController;
```
#### 内置属性
业务`Controller`继承自框架内置的`Controller`，在`Controller`实例中可访问到的内置属性如下：

| 属性 | 描述 |
| --- | --- |
| app | 应用实例 |
| config | 应用配置 |

#### 访问
框架在加载目录单元时会将`app/controller`目录下定义的`Controller`扩展到`Application`中，因此在`Gulu`应用内部可通过`app.controller.${Controller文件名的驼峰形式}`访问到具体的`Controller`实例。一般情况下，只在路由文件中访问`Controller`实例。


### 3.7 Service
#### 写法
```javascript
// app/service/app.js
const { Service } = require('byted-gulu');

class AppService extends Service {
    async query() {
        return this.ctx.model.App.findAll();
    }
}

module.exports = AppService;
```

#### 内置属性
业务`Service`继承自框架内置的`Service`，在`Service`实例中可访问到的内置属性如下：

| 属性 | 描述 |
| --- | --- |
| ctx | 上下文实例 |
| app | 应用实例 |
| config | 应用配置 |

#### 访问
框架在加载目录单元时会将`app/service`目录下定义的业务逻辑单元扩展到`Context`中，因此在`Gulu`应用内部可以通过`ctx.service.${service文件名的驼峰形式}`访问到具体的`Service`实例。例如，在`Controller`中，可通过`ctx.service.app`访问到`app/service/app.js`文件中定义的`Service`类的实例。

### 3.8 扩展
在某些场景下，我们希望在应用实例、上下文实例、请求实例或者响应实例上挂载一些工具方法以便使用，这个时候可以使用框架提供的扩展功能。扩展定义放置在`app/extension`目录下。
 - `app/extension/app.js`：应用扩展
 - `app/extension/context.js`：上下文扩展
 - `app/extension/request.js`：请求扩展
 - `app/extension/response.js`： 响应扩展

#### 写法
**方法一：导出扩展生成函数，适用于动态扩展**
```javascript
module.exports = (app) => {
    return {
        get test() {
            return 'test';
        }
    };
}
```

**方法二：导出扩展对象，适用于静态扩展**
```
module.exports = {
	get test() {
	    return 'test';
    }
};
```
框架会将导出的返回的对象合并到目标扩展对象的原型上。

### 3.9 中间件

#### 使用
中间件的加载通过配置项`middleware`控制，如果要使用中间件，只需要在`middleware`配置项中添加要使用的中间件的名字即可。如果需要给中间件传配置参数，可以应用配置中添加配置项，配置项的`key`中间件名称的驼峰形式，配置项的值为要传的参数。
```javascript
module.exports = {
    middleware: [
        'koa-body', // 中间件名称
    ],
    koaBody: {
	    // 中间件配置参数
    },
};
```

中间件的函数签名必须符合以下两种形式之一：
- `(options) => {}`
- `(options, app) => {}`
其中，`options`为对象，`app`为应用实例。

对于不符合以上要求的第三方中间件，需经过移植才能使用。


#### 查找
框架在加载中间件时，会按以下顺序查找：
- 当前目录单元的`app/middleware`目录
- 当前目录单元的`node_modules`目录
- 应用目录的`node_modules`目录

#### 中间件的启用和禁用
在配置文件中，可以通过`enableMiddleware`配置项来对所有中间件进行全局控制。在每个中间件执行之前，都会先执行`enableMiddleware`来判断当前中间件是否会被启用。`enableMiddleware`支持`async function`的写法。
```javascript
module.exports = {
    enableMiddleware: (ctx, middleware) => {
        // 动态逻辑
        return true;
    }
};
```

如果只想控制具体的中间件是否启用，也可在中间件加载配置中这么写
```javascript
module.exports = {
    middleware: [
        {
            name: 'foo',
            enable: (ctx, middleware) => {
                // 动态逻辑
                return true;
            }
        },
    ],    
};
```

注意：中间件启用判断函数中传递的`middleware`参数是一个对象，具备如下结构：
```javascript
{
    name: '',  // 中间件名称
    pkg: {},   // 如果中间件时npm包，则该字段存储package.json的信息
    path: '',  // 中间件路径
}
```

### 3.10 插件

#### 使用
插件的加载通过配置项`plugin`控制，如果需要使用插件，只需要在配置项`plugin`中添加要使用的插件的名字即可。
```javascript
module.exports = (app) => {
    return {
        plugin: [
            'byted-gulu-redis', // 插件名称
        ],       
    };
}
```

**注意：一般地，插件会有相应的配置，但是插件配置项的名称与插件的名称没有必然的联系，插件需要什么配置由插件自身决定，应参考插件的使用文档。但是对于插件编写者，建议插件的配置项命名应与插件名称相关联**


### 3.11 Router
#### 写法
```javascript
// app/router.js
module.exports = (app) => {
    const { router, controller } = app;
    
    router.get('/app', controller.app.query);
    router.get('/', controller.index.index);
}
```

`router`就是常用的`koa-router`实例。