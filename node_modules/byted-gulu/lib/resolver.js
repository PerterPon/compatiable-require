const fs = require('fs');
const path = require('path');
const assert = require('assert');
const extend = require('extend');
const is = require('is-type-of');

class Resolver {
    constructor(app) {
        this.app = app;
    }

    /**
     * 查找功能单元
     * @param {String} root - 功能单元根目录
     */
    resolveUnit(root) {
        const unit = this.app.loader.load(root);        
        const queue = [ unit ];

        while (queue.length > 0) {
            const item = queue.pop();
            const plugins = item.config.plugin || [];
            const dependencies = [];            
            for (const plugin of plugins) {
                const name = is.object(plugin) ? plugin.name : plugin;
                const enable = is.object(plugin) ? plugin.enable : true;
                if (enable === false) {
                    continue;
                }
                const pluginPath = this.resolvePlugin(item.root, name);
                const dependency = this.app.loader.load(pluginPath);
                dependencies.push(dependency);      
            }            
            item.dependencies = dependencies;
            queue.push.apply(queue, dependencies);
        }
        
        return unit;
    }

    /**
     * 查找插件
     * @param {String} root - 功能单元根目录
     * @param {String} name - 插件名称
     */
    resolvePlugin(root, name) {
        const searchPaths = [
            path.resolve(root, 'app', 'plugin'),
            path.resolve(root, 'node_modules'),
            path.resolve(this.app.root, 'node_modules'),
        ];

        let pluginPath;
        for (const searchPath of searchPaths) {            
            const candidatePath = path.resolve(searchPath, name);
            if (fs.existsSync(candidatePath) && fs.statSync(candidatePath).isDirectory()) {
                pluginPath = candidatePath;
                break;
            }
        }

        assert(pluginPath, `Can't find plugin '${name}'`);

        return pluginPath;
    }

    /**
     * 查找中间件
     * @param {String} root - 功能单元根目录
     * @param {String} name - 中间件名称
     */
    resolveMiddleware(root, name) {
        const searchPaths = [
            path.resolve(root, 'app', 'middleware'),
            path.resolve(root, 'node_modules'),
            path.resolve(this.app.root, 'node_modules'),
        ];

        let middlewarePath;
        let middleware;        
        for (const searchPath of searchPaths) {
            try {
                middlewarePath = path.resolve(searchPath, name);
                middleware = require(middlewarePath);
                break;
            } catch(e) {
                continue;
            }
        }

        assert(middleware, `Can't find middleware '${name}'`);

        let pkg;
        try {
            pkg = require(path.resolve(middlewarePath, 'package.json'));
        } catch (e) {
            pkg = null;
        }

        return {
            middleware: (options, app, enable) => {           
                const middlewareFunc = middleware(options, app);
                const enableMiddleware = app.config.enableMiddleware;

                return async (ctx, next) => {                                     
                    if (enableMiddleware === false) {
                        return next();
                    }
                    if (is.function(enableMiddleware)) {
                        const isEnabled = enableMiddleware(ctx, { name, pkg, path: middlewarePath });
                        if (isEnabled === false) {
                            return next();
                        }
                    }
                    if (is.asyncFunction(enableMiddleware)) {
                        const isEnabled = await enableMiddleware(ctx, { name, pkg, path: middlewarePath });
                        if (isEnabled === false) {
                            return next();
                        }
                    }

                    if (enable === false) {
                        return next();
                    }
                    if (is.function(enable)) {
                        const isEnabled = enable(ctx, { name, pkg, path: middlewarePath });
                        if (isEnabled === false) {
                            return next();
                        }
                    }
                    if (is.asyncFunction(enable)) {
                        const isEnabled = await enable(ctx, { name, pkg, path: middlewarePath });
                        if (isEnabled === false) {
                            return next();
                        }
                    }
                    return middlewareFunc(ctx, next);
                };
            },
            pkg,
            path: middlewarePath,
        };
    }
}

module.exports = Resolver;